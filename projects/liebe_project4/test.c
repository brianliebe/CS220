//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2016 Retargetable Decompiler <info@retdec.com>
//

#include <signal.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <unistd.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int32_t __do_global_dtors_aux(int32_t a1);
int32_t __i686_get_pc_thunk_bx(void);
void __libc_csu_fini(void);
int32_t __libc_csu_init(int32_t a1, int32_t a2, int32_t a3);
int32_t _start(int32_t a1, int32_t a2);
int32_t deregister_tm_clones(void);
int32_t explode(void);
int32_t frame_dummy(int32_t a1);
int32_t func_1220(int32_t a1);
int32_t func_1221(char * str);
int32_t initialize(void);
int32_t is_resign(char * a1);
int main(int argc, char ** argv);
int32_t phase0(int32_t a1);
int32_t phase1(int32_t a1);
int32_t phase2(int32_t a1);
char * read_3_numbers(struct _IO_FILE * stream, int32_t * a2);
char * read_4_strings(char ** stream, int32_t * a2);
char * read_input_phase2(struct _IO_FILE * stream, int32_t * a2);
int32_t register_tm_clones(int32_t a1);

// --------------------- Global Variables ---------------------

int32_t g1 = 0; // eax
int32_t g2 = 0; // ebp
int32_t g3 = 0; // ecx
int32_t g4 = 0; // edx
int32_t g5 = 0x17b72; // 0x804a160
int32_t g6 = 0; // 0x804a180
char g7 = 0; // 0x804a184
struct _IO_FILE * g8 = NULL; // 0x804a1a0
int32_t g9 = 0; // 0x804a1c0
int32_t g10 = 0; // 0x804a600
int32_t g11 = 0; // 0x804aa40

// ------------------------ Functions -------------------------

// Address range: 0x80486f0 - 0x804871f
int32_t _start(int32_t a1, int32_t a2) {
    int32_t v1;
    int32_t result = __libc_start_main((int32_t * (*)(int32_t, char **, char **))main, v1, (char **)&a1, (void (**)())__libc_csu_init, (void (**)())__libc_csu_fini, (void (**)())g4); // 0x804870c
    g1 = result;
    return result;
}

// Address range: 0x8048720 - 0x804874f
int32_t deregister_tm_clones(void) {
    // 0x8048720
    return g2;
}

// Address range: 0x8048750 - 0x804878f
int32_t register_tm_clones(int32_t a1) {
    // 0x8048750
    return 0;
}

// Address range: 0x8048790 - 0x80487af
int32_t __do_global_dtors_aux(int32_t a1) {
    int32_t result;
    if (g7 == 0) {
        // 0x8048799
        result = g2;
        g2 = &result;
        deregister_tm_clones();
        g7 = 1;
        // branch -> 0x80487ac
    }
    // 0x80487ac
    return result;
}

// Address range: 0x80487b0 - 0x80487db
int32_t frame_dummy(int32_t a1) {
    // 0x80487b0
    register_tm_clones(a1);
    return 0;
}

// Address range: 0x80487dc - 0x80487f9
int32_t explode(void) {
    int32_t v1;
    g2 = &v1;
    puts("!!!BOOM!!! You're toast.");
    exit(-255);
    // UNREACHABLE
}

// Address range: 0x80487fa - 0x8048868
int32_t initialize(void) {
    // branch -> 0x804881e
    for (int32_t i = 1; i < 272; i++) {
        int32_t v1 = 4 * i; // 0x804882b
        *(int32_t *)(v1 + (int32_t)&g10) = i + (int32_t)func_1220;
        *(int32_t *)(v1 + (int32_t)&g11) = i + (int32_t)is_resign;
        *(int32_t *)(v1 + (int32_t)&g9) = (int32_t)read_3_numbers + i;
        // continue -> 0x804881e
    }
    // 0x8048867
    return 271;
}

// Address range: 0x8048869 - 0x80488c4
int32_t is_resign(char * a1) {
    int32_t v1 = (int32_t)a1;
    int32_t v2;
    if (*a1 == 114) {
        // 0x8048876
        if (*(char *)(v1 + 1) == 101) {
            // 0x8048883
            if (*(char *)(v1 + 2) == 115) {
                // 0x8048890
                if (*(char *)(v1 + 3) == 105) {
                    // 0x804889d
                    if (*(char *)(v1 + 4) == 103) {
                        // 0x80488aa
                        if (*(char *)(v1 + 5) == 110) {
                            // 0x80488c3
                            g2 = v2;
                            return 1;
                        }
                    }
                }
            }
        }
    }
    // 0x80488be
    // branch -> 0x80488c3
    // 0x80488c3
    g2 = v2;
    return 0;
}

// Address range: 0x80488c5 - 0x8048972
char * read_3_numbers(struct _IO_FILE * stream, int32_t * a2) {
    int32_t str;
    memset((char *)&str, 0, 1024);
    char * mem = malloc(12); // 0x80488f3
    int32_t v1 = (int32_t)mem; // 0x80488f3_3
    fgets((char *)&str, 1023, stream);
    int32_t items_assigned = sscanf((char *)&str, "%d %d %d", mem, (int32_t *)(v1 + 4), (int32_t *)(v1 + 8));
    int32_t v2;
    if (items_assigned != 3) {
        // 0x8048952
        is_resign((char *)&str);
        *a2 = (int32_t)&str;
        v2 = 0;
        // branch -> 0x8048971
    } else {
        v2 = v1;
    }
    // 0x8048971
    int32_t v3;
    g2 = v3;
    return (char *)v2;
}

// Address range: 0x80489c2 - 0x8048b1c
char * read_4_strings(char ** stream, int32_t * a2) {
    char * mem = malloc(16); // 0x80489d3
    int32_t v1 = (int32_t)mem; // 0x80489d3_3
    *(int32_t *)mem = (int32_t)malloc(128);
    char * mem2 = malloc(128); // 0x80489fb
    int32_t * v2 = (int32_t *)(v1 + 4); // 0x8048a00_0
    *v2 = (int32_t)mem2;
    char * mem3 = malloc(128); // 0x8048a0f
    int32_t * v3 = (int32_t *)(v1 + 8); // 0x8048a14_0
    *v3 = (int32_t)mem3;
    char * mem4 = malloc(128); // 0x8048a23
    int32_t * v4 = (int32_t *)(v1 + 12); // 0x8048a28_0
    *v4 = (int32_t)mem4;
    int32_t str;
    memset((char *)&str, 0, 1024);
    fgets((char *)&str, 1023, (struct _IO_FILE *)stream);
    int32_t v5 = *v4; // 0x8048a6b
    int32_t v6 = *v3; // 0x8048a73
    int32_t v7 = *v2; // 0x8048a7b
    int32_t v8 = *(int32_t *)mem; // 0x8048a80
    int32_t items_assigned = sscanf((char *)&str, "%s %s %s %s", (char **)v8, (char **)v7, (char **)v6, (char **)v5);
    int32_t v9;
    if (items_assigned != 4) {
        // 0x8048aad
        is_resign((char *)&str);
        *a2 = (int32_t)&str;
        free((char *)*(int32_t *)mem);
        free((char *)*v2);
        free((char *)*v3);
        free((char *)*v4);
        free(mem);
        v9 = 0;
        // branch -> 0x8048b14
    } else {
        v9 = v1;
    }
    // 0x8048b14
    return (char *)v9;
}

// Address range: 0x8048b1d - 0x8048b9a
int32_t func_1221(char * str) {
    uint32_t len = strlen(str); // 0x8048b31
    if (len == 0) {
        // 0x8048b92
        return 0;
    }
    int32_t v1 = 0;
    int32_t v2 = 0; // 0x8048b921315
    while (true) {
        char * v3 = (char *)((int32_t)str + v1);
        int32_t v4; // 0x8048b86
        int32_t result; // 0x8048b9212
        if (*v3 == 49) {
            uint32_t v5 = (len - v1 - 1) % 32; // 0x8048b69
            int32_t v6 = 1; // 0x8048b6b
            if (v5 != 0) {
                // if_8048b69_0_true
                v6 = 1 << v5;
                // branch -> after_if_8048b69_0
            }
            // after_if_8048b69_0
            result = v6 | v2;
            // branch -> 0x8048b86
        } else {
            // 0x8048b72
            if (*v3 != 48) {
                // 0x8048b81
                explode();
                result = v2;
                // branch -> 0x8048b86
            } else {
                result = v2;
            }
            // 0x8048b86
            v4 = v1 + 1;
            if (len <= v4) {
                // 0x8048b92
                return result;
            }
          lab_0x8048b86:
            // 0x8048b86
            v1 = v4;
            v2 = result;
            // branch -> 0x8048b42
            continue;
        }
        // 0x8048b86
        v4 = v1 + 1;
        if (len > v4) {
            goto lab_0x8048b86;
        }
        // 0x8048b92
        return result;
    }
}

// Address range: 0x8048b9b - 0x8048d08
int32_t phase0(int32_t a1) {
    int32_t v1 = 0; // bp-24
    char * str = read_4_strings((char **)a1, &v1); // 0x8048bb5
    int32_t v2 = (int32_t)str; // 0x8048bb5_3
    int32_t puts_rc; // 0x8048d08_2
    if (v1 == 1) {
        // 0x8048bc5
        puts_rc = puts("You gave up Phase 0...");
        // branch -> 0x8048d07
    } else {
        // 0x8048bd6
        if (str == NULL) {
            // 0x8048bdc
            explode();
            // branch -> 0x8048be1
        }
        // 0x8048be1
        int32_t v3;
        if (sscanf((char *)*(int32_t *)str, "%x", &v3) != 1) {
            // 0x8048c02
            explode();
            // branch -> 0x8048c07
        }
        int32_t * str2 = (int32_t *)(v2 + 4); // 0x8048c0d_0
        int32_t v4;
        if (sscanf((char *)*str2, "%u", &v4) != 1) {
            // 0x8048c2b
            explode();
            // branch -> 0x8048c30
        }
        int32_t * str3 = (int32_t *)(v2 + 8); // 0x8048c36_0
        int32_t v5;
        if (sscanf((char *)*str3, "%o", &v5) != 1) {
            // 0x8048c54
            explode();
            // branch -> 0x8048c59
        }
        int32_t * v6 = (int32_t *)(v2 + 12); // 0x8048c5f_0
        int32_t v7 = func_1221((char *)*v6); // 0x8048c64
        int32_t v8 = v3; // 0x8048c6c
        int32_t v9 = v4; // 0x8048c77
        int32_t v10 = v9; // 0x8048c96
        int32_t v11 = v8; // 0x8048c93
        if ((v8 & 0xf299) != (v5 || v9)) {
            // 0x8048c83
            explode();
            v10 = v4;
            v11 = v3;
            // branch -> 0x8048c88
        }
        // 0x8048c88
        if ((v7 & 0xf299) != (v11 || v10)) {
            // 0x8048c9f
            explode();
            // branch -> 0x8048ca4
        }
        // 0x8048ca4
        free((char *)*(int32_t *)str);
        free((char *)*str2);
        free((char *)*str3);
        free((char *)*v6);
        free(str);
        puts("Phase 0 solved.");
        int32_t v12 = g5 - 0x1790; // 0x8048cfd
        g5 = v12;
        puts_rc = v12;
        // branch -> 0x8048d07
    }
    // 0x8048d07
    return puts_rc;
}

// Address range: 0x8048d09 - 0x8048e59
int32_t phase1(int32_t a1) {
    int32_t v1 = 0; // bp-36
    char * v2 = read_3_numbers((struct _IO_FILE *)a1, &v1); // 0x8048d23
    int32_t v3 = (int32_t)v2; // 0x8048d23_3
    int32_t puts_rc; // 0x8048e59_2
    if (v1 == 1) {
        // 0x8048d33
        puts_rc = puts("You gave up Phase 1...");
        // branch -> 0x8048e58
    } else {
        // 0x8048d44
        if (v2 == NULL) {
            // 0x8048d4a
            explode();
            // branch -> 0x8048d4f
        }
        int32_t v4 = v3 + 4;
        int32_t result; // 0x8048e4e
        int32_t * v5;
        int32_t v6; // 0x8048ded
        int32_t v7; // 0x8048e09
        int32_t v8; // 0x8048e25
        int32_t v9; // 0x8048df1
        int32_t v10; // 0x8048e0d
        int32_t v11; // 0x8048e29
        if (-*(int32_t *)v2 < -0xf299) {
            // 0x8048d4f
            v5 = (int32_t *)v4;
            // branch -> 0x8048ddc
        } else {
            int32_t * v12 = (int32_t *)v4; // 0x8048d69_0
            if (-*v12 >= 0xffff0d67) {
                int32_t * v13 = (int32_t *)(v3 + 8); // 0x8048d80_0
                if (-*v13 >= 0xffff0d67) {
                    // 0x8048d91
                    if (-*(int32_t *)v2 <= 0xffff0e76) {
                        // 0x8048da8
                        if (-*v12 <= 0xffff0e76) {
                            // 0x8048dc2
                            if (-*v13 < -0xf189) {
                                // 0x8048de1
                                g4 = 0xf299;
                                v6 = 0xf299 - *(int32_t *)v2;
                                g3 = v6;
                                v9 = *(int32_t *)(4 * v6 + (int32_t)&g10);
                                g1 = v9;
                                ((int32_t (*)())v9)();
                                g4 = 0xf299;
                                v7 = 0xf299 - *v12;
                                g3 = v7;
                                v10 = *(int32_t *)(4 * v7 + (int32_t)&g11);
                                g1 = v10;
                                ((int32_t (*)())v10)();
                                g4 = 0xf299;
                                v8 = 0xf299 - *v13;
                                g3 = v8;
                                v11 = *(int32_t *)(4 * v8 + (int32_t)&g9);
                                g1 = v11;
                                ((int32_t (*)())v11)();
                                free(v2);
                                puts("Phase 1 solved.");
                                result = g5 + 1436;
                                g5 = result;
                                // branch -> 0x8048e58
                                // 0x8048e58
                                return result;
                            }
                            v5 = v12;
                        } else {
                            v5 = v12;
                        }
                    } else {
                        v5 = v12;
                    }
                } else {
                    v5 = v12;
                }
            } else {
                v5 = v12;
            }
        }
        // 0x8048ddc
        explode();
        // branch -> 0x8048de1
        // 0x8048de1
        g4 = 0xf299;
        v6 = 0xf299 - *(int32_t *)v2;
        g3 = v6;
        v9 = *(int32_t *)(4 * v6 + (int32_t)&g10);
        g1 = v9;
        ((int32_t (*)())v9)();
        g4 = 0xf299;
        v7 = 0xf299 - *v5;
        g3 = v7;
        v10 = *(int32_t *)(4 * v7 + (int32_t)&g11);
        g1 = v10;
        ((int32_t (*)())v10)();
        g4 = 0xf299;
        v8 = 0xf299 - *(int32_t *)(v3 + 8);
        g3 = v8;
        v11 = *(int32_t *)(4 * v8 + (int32_t)&g9);
        g1 = v11;
        ((int32_t (*)())v11)();
        free(v2);
        puts("Phase 1 solved.");
        result = g5 + 1436;
        g5 = result;
        puts_rc = result;
        // branch -> 0x8048e58
    }
    // 0x8048e58
    return puts_rc;
}

// Address range: 0x8048e5a - 0x8048f42
int32_t func_1220(int32_t a1) {
    if (a1 == 2) {
        // 0x8048e7e
        if (g5 == 0x16971) {
            // 0x8048e8e
            puts("You have unlocked the secret phase!");
            int32_t str;
            fgets((char *)&str, 1023, g8);
            int32_t str2;
            sprintf((char *)&str2, "%s%x", "GONZO1982_", 0x1e53);
            int32_t len = strlen((char *)&str2); // 0x8048ee8
            if (strncmp((char *)&str2, (char *)&str, len) == 0) {
                // 0x8048f0d
                puts("Secret phase solved. You have diffused the bomb! :)");
                exit(0);
                // UNREACHABLE
            }
            // 0x8048f25
            puts("You failed!");
            explode();
            // branch -> 0x8048f41
        }
    } else {
        // 0x8048e6b
        explode();
        // branch -> 0x8048f41
    }
    // 0x8048f41
    return g5;
}

// Address range: 0x8048f43 - 0x8049092
char * read_input_phase2(struct _IO_FILE * stream, int32_t * a2) {
    int32_t str;
    int32_t v1 = &str; // 0x8048f5c_0
    memset((char *)&str, 0, 1024);
    char * v2 = memalign(0x1000, 0x1000); // 0x8048f79
    int32_t v3 = (int32_t)v2; // 0x8048f79_5
    if (v2 == NULL) {
        // 0x8048f87
        puts("in null");
        // branch -> 0x8048f93
    }
    // 0x8048f93
    if (fgets((char *)&str, 1023, stream) != (char *)&str) {
        // 0x8048fba
        puts("pgets failed");
        // branch -> 0x8048fc6
    }
    // 0x8048fc6
    is_resign((char *)&str);
    g4 = v1;
    *a2 = v1;
    int32_t v4;
    if (*a2 != 0) {
        // 0x8049091
        g2 = v4;
        return (char *)0;
    }
    uint32_t len = strlen((char *)&str); // 0x8048ff7
    if (len == 0) {
        // 0x8049052
        if (mprotect(v2, 0x1000, 5) == 0) {
            // 0x8049091
            g2 = v4;
            return (char *)v3;
        }
        // 0x8049076
        perror("mprotect Error: SHOULD NOT HAPPEN. Contact TAs");
        exit(-1);
        // UNREACHABLE
    }
    int32_t v5 = 0;
    int32_t v6 = 0; // 0x80490471214
    while (true) {
        int32_t v7 = v5 + v3; // 0x8049015
        g4 = v7;
        g3 = v1;
        int32_t items_assigned = sscanf((char *)(v6 + v1), "%x", &((struct _IO_FILE *)v7)->e0);
        if (items_assigned == 1) {
            int32_t v8 = v6 + 3; // 0x804903f
            if (v8 >= len) {
                // break -> 0x8049052
                break;
            }
            v5++;
            v6 = v8;
            // continue -> 0x804900f
            continue;
        }
    }
    // 0x8049052
    if (mprotect(v2, 0x1000, 5) == 0) {
        // 0x8049091
        g2 = v4;
        return (char *)v3;
    }
    // 0x8049076
    perror("mprotect Error: SHOULD NOT HAPPEN. Contact TAs");
    exit(-1);
    // UNREACHABLE
}

// Address range: 0x8049093 - 0x804915d
int32_t phase2(int32_t a1) {
    int32_t v1 = 0; // bp-24
    char * v2 = read_input_phase2((struct _IO_FILE *)a1, &v1); // 0x80490ad
    int32_t v3 = (int32_t)v2; // 0x80490ad_3
    int32_t puts_rc; // 0x804915d_2
    if (v1 == 1) {
        // 0x80490bd
        puts_rc = puts("You gave up Phase 2...");
        // branch -> 0x804915c
    } else {
        // 0x80490ce
        if (v2 == NULL) {
            // 0x80490d4
            explode();
            // branch -> 0x80490d9
        }
        // 0x80490d9
        g1 = v3;
        ((int32_t (*)(int32_t, int32_t))v2)(10, 205);
        if (g1 != 8) {
            // 0x80490f8
            explode();
            // branch -> 0x80490fd
        }
        // 0x80490fd
        g1 = v3;
        ((int32_t (*)(int32_t, int32_t))v2)(18, 56);
        if (g1 != 16) {
            // 0x8049116
            explode();
            // branch -> 0x804911b
        }
        // 0x804911b
        g1 = v3;
        ((int32_t (*)(int32_t, int32_t))v2)(1, 0);
        if (g1 != 0) {
            // 0x8049133
            explode();
            // branch -> 0x8049138
        }
        // 0x8049138
        free(v2);
        puts("Phase 2 solved.");
        int32_t v4 = g5 - 13; // 0x8049154
        g5 = v4;
        puts_rc = v4;
        // branch -> 0x804915c
    }
    // 0x804915c
    return puts_rc;
}

// Address range: 0x804915e - 0x80492af
int main(int argc, char ** argv) {
    // 0x8049180
    int32_t v1; // bp-44
    int32_t v2 = &v1; // 0x8049168_0
    v1 = 0;
    int32_t v3 = 4; // eax
    int32_t v4 = 4; // 0x804918337
    // branch -> 0x8049180
    while (true) {
        // 0x8049180
        *(int32_t *)(v2 + v4) = 0;
        int32_t v5 = v3 + 4; // 0x8049183
        v3 = v5;
        if (v5 >= 24) {
            // 0x804918a
            if (argc < 2) {
                // 0x80491d5
                g8 = (struct _IO_FILE *)g6;
                // branch -> 0x8049206
            } else {
                struct _IO_FILE * file = fopen((char *)*(int32_t *)((int32_t)argv + 4), "r"); // 0x80491bd
                g8 = file;
                if (file == NULL) {
                    int32_t v6 = *(int32_t *)argv; // 0x8049284
                    printf("Usage: %s OR %s <file>\n", (char *)v6, (char *)*(int32_t *)argv);
                    // branch -> 0x804929f
                    // 0x804929f
                    return -1;
                }
            }
            // branch -> 0x80491e9
            for (int32_t i = 0; i < 12; i++) {
                // 0x80491e9
                __sysv_signal(*(int32_t *)(24 + 4 * i), (void (**)(int32_t))func_1220);
                // continue -> 0x80491e9
            }
            // 0x804920f
            initialize();
            puts("Phase 0:");
            phase0((int32_t)g8);
            puts("Phase 1:");
            phase1((int32_t)g8);
            puts("Phase 2:");
            v1 = 0x444e41;
            phase2((int32_t)g8);
            sleep(1);
            // branch -> 0x804929f
            // 0x804929f
            return 0;
        }
        // 0x8049180
        v4 = v5;
        // branch -> 0x8049180
    }
}

// Address range: 0x80492b0 - 0x80492bf
void __libc_csu_fini(void) {
    // 0x80492b0
    return;
}

// Address range: 0x80492c0 - 0x8049319
int32_t __libc_csu_init(int32_t a1, int32_t a2, int32_t a3) {
    // 0x80492c0
    __i686_get_pc_thunk_bx();
    abort();
    // UNREACHABLE
}

// Address range: 0x804931a - 0x804931f
int32_t __i686_get_pc_thunk_bx(void) {
    // 0x804931a
    int32_t result;
    return result;
}

// --------------- Dynamically Linked Functions ---------------

// int __libc_start_main(int *(main)(int, char **, char **), int argc, char ** ubp_av, void(* init)(void), void(* fini)(void), void(* rtld_fini)(void), void(* stack_end));
// __sighandler_t __sysv_signal(int sig, __sighandler_t handler);
// void exit(int status);
// char * fgets(char * restrict s, int n, FILE * restrict stream);
// FILE * fopen(const char * restrict filename, const char * restrict modes);
// void free(void * ptr);
// void * malloc(size_t size);
// void * memalign(size_t alignment, size_t size);
// void * memset(void * s, int c, size_t n);
// int mprotect(void * addr, size_t len, int prot);
// void perror(const char * s);
// int printf(const char * restrict format, ...);
// int puts(const char * s);
// unsigned int sleep(unsigned int seconds);
// int sprintf(char * restrict s, const char * restrict format, ...);
// int sscanf(const char * restrict s, const char * restrict format, ...);
// size_t strlen(const char * s);
// int strncmp(const char * s1, const char * s2, size_t n);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (4.7.2)
// Detected functions: 20
// Decompiler release: v2.2.1 (2016-09-07)
// Decompilation date: 2016-12-12 03:25:55
